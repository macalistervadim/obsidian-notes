Алгоритм быстрой сортировки не только быстрый, но еще и максимально прост в реализации. Достигается его быстрота путем использования стратегии "Разделяй и властвуй", которая в свою очередь основана на базе рекурсии.

>[!info] совет
>Если мы пишем рекурсию, в которой фигурируют массивы, нашим базовым случаем будет массив, содержащий менее двух элементов (пустой или же содержащий 1 элемент). В БОЛЬШИНСТВЕ СЛУЧАЕВ!
### Реализация алгоритма

Алгоритм работает по следующему принципу:
- Как свойственно для каждой рекурсивной ф-ции, создаем базовый и рекурсивный случая. Так как здесь у нас задействован массив, базовым случаем у нас будет любой массив, содержащий менее 2х элементов (массивы [], [1], [2])
- Далее определяем наш опорный элемент
- При помощи listcomp разделяем наш начальный список на 3 - это меньше опорного числа, равные (на случай, если у нас есть дубляжи), а также больше опорного элемента
- Далее полученные разделенные списки мы соединяем воедино, рекурсивно сортируя каждый их них

```python
def quick_sort(numbers):  
    if len(numbers) < 2:  
        return numbers  
    else:  
        pivot = numbers[len(numbers) // 2]  
  
        left = [i for i in numbers if i < pivot]  
        middle = [i for i in numbers if i == pivot]  
        right = [i for i in numbers if i > pivot]  
  
        return quick_sort(left) + middle + quick_sort(right)  
  
print(quick_sort([5, 4, 3, 2, 1, 100, -20]))
```

>[!danger] Очень важно
> Алгоритм быстрой сортировки аннотируется как О(n log n). Но очень важно подметить, что его скорость зависит напрямую от выбора опорного элемента, если сделать неудачный выбор опорного элемента - скорость алгоритма может в разы уменьшиться. Оптимальным вариантом будет выбрать средний элемент

[[Python]] [[IT]]
