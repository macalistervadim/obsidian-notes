 Алгоритм сортировки выбором - хороший инструмент для сортировки с использованием дополнительного списка (заранее пустого), который выполняется за *O(n2) - квадратичное время*. Это очень простой и легкий в реализации алгоритм, но он дико медленный и подходит для очень малого спектра данных

#### Реализация алгоритма
- Мы создаем отдельную функцию для поиска наименьшего элемента в списке
- В этой функции мы задаем две переменные - smallest = arr[0] и smallest_index = 0 - они нам необходимы для начальной инициализации неких указателей на наши наименьшие элементы
- После чего в цикле мы перебираем переданный на вход список, сравнивая текущий итерируемый элемент с нашим указателeм (smallest), если он меньше - то присваиваем smallest значение этого элемента и изменяем указатель smallest_index на текущую итерацию (так как мы итерируемся по длине списка - текущая итерация совпадает с индексацией)
- Теперь создаем функцию самой сортировки
- В ней мы задаем пустой список, в который и будем собирать сортированные элементы
- Далее в цикле проходимся по длине нашего переданного списка
- Вызываем нашу функцию для поиска наименьшего элемента и сохраняем результат в переменную
- Вызванную функцию (уже значение, которое вернула функция) записываем в наш отсортированный список 

```python
def find_smallest(arr: MutableSequence[int]) -> int:  
    smallest = arr[0]  
    smallest_index = 0  
    for i in range(1, len(arr)):  
        if arr[i] < smallest:  
            smallest = arr[i]  
            smallest_index = i  
  
    return smallest_index  
  
  
def selection_sort(arr: MutableSequence[int]) -> MutableSequence[int]:  
    new_arr = []  
    for i in range(len(arr)):  
        smallest = find_smallest(arr)  
        new_arr.append(arr.pop(smallest))  # pop удаляет элемент и возвращает его

	return new_arr
```


[[IT]] [[Python]] [[Родительские классы/IT/Python/Leetcode|Leetcode]]

