> Графы в питоне также создаются при помощи словарей :)

Алгоритм поиска в ширину позволяет ответить нам на два важных вопроса:
- Кратчайший путь от А до Б
- Существует ли путь из А в Б

Там также задействованы Стеки (LIFO) и Очереди (FIFO)

#### Реализация алгоритма

Алгоритм работает по следующему принципу:
- У нас имеется некий пустой список "посещенных мест" - тобишь тех точек в графе, которые мы уже прошли
- Также у нас имеется второй список, но уже "не посещенных мест" - грубо говоря очередь, которую нам необходимо обойти. Изначально он не пуст, а инициализируется принимаемой в функции стартовой точкой
- Далее мы попросту итерируемся в цикле по нашей очереди, вынимая оттуда следующую точку
- Проверяем, имеется ли только что вынутая точка в уже "посещенных местах"
- Если нет, то берем всех "соседей" данной точки в при помощи итерации закидываем их в "непосещенные места"

```python
def BFS(graph, start_dot):  
    visited = []  
    queue = [start_dot]  
  
    while queue:  
        this = queue.pop(0)  
        if this not in visited:  
            visited.append(this)  
  
            neighbours = graph[this]  
            for neighbour in neighbours:  
                queue.append(neighbour)  
  
    return visited  
  
graph = {  
    "Amin": {"Wasim", "Nick", "Mike"},  
    "Wasim": {"Imran", "Amin"},  
    "Imran": {"Wasim", "Faras"},  
    "Faras": {"Imran"},  
    "Mike": {"Amin"},  
    "Nick": {"Amin"},  
}  
  
print(BFS(graph, "Amin"))
```

[[Python]] [[IT]] [[Родительские классы/IT/Python/Leetcode|Leetcode]]

