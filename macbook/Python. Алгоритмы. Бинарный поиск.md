> Бинарный поиск чаще всего применяется в тех случаях, когда необходимо быстро и эффективно найти тот или иной элемент в списке или массиве


Алгоритм бинарного поиска работает по принципу отсичения половины - на каждой итерации нашего цикла мы "отрубаем" половину из тех элементов, которые меньше/больше заданного числа и движемся уже по новым границам

#### Реализация алгоритма

Алгоритм работает по следующему принципу:
- Мы заводим две переменные - low и high, это будут наши границы, тобишь то, что будет ограничивать наш поиск 
- Далее мы заводим цикл `while low <= high` (до момента, пока не усечемся до единственного элемента)
- В этом цикле мы каждый раз будем находить середину нашей границы - `low+high // 2` (// округляет результат в меньшую сторону)
- И соответственно теперь, когда все границы и данные определены, мы при помощи условных выражений сравниваем искомое число и найденное число при помощи усечения
- Если оно равно - возвращаем, если больше - усекаем нашу верхнюю границу `high` (`high = middle - 1`), если меньше - увеличиваем нашу границу `low` (`low = middle + 1`)
- Таким образом, мы на каждой итерации нашего цикла отсекаем половину из ненужных нам чисел, постоянно меняя наши границы и получая новую середину

>[!danger] Очень важно!
>Прошу заметить, что алгоритм бинарного поиска работает исключительно на отсортированных данных

```python
class NotFindThisNumber(ValueError):  
    pass  
  
def binary_search(numbers, target):  
    low_number_index = 0  
    high_number_index = len(numbers) - 1  
  
    while low_number_index <= high_number_index:  
        middle_number_index = (low_number_index + high_number_index) // 2  
        gues_number = numbers[middle_number_index]  
  
        if gues_number == target:  
            return middle_number_index  
        elif gues_number < target:  
            low_number_index = middle_number_index + 1  
        else:  
            high_number_index = middle_number_index - 1  
  
    raise NotFindThisNumber(f"Number {target} not found in numbers")  
  
  
print(binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9], 9)) 
```

==Бинарный поиск выполяется за логарифмическое время - O(log n)==

>[!example] Как он работает?
>Нам необходимо найти верхнюю и нижнюю границу того или иного списка или массива, (low = 0), а также верхнюю (high = len(list) - 1)
>>[!danger] Для чего мы делаем в `high` - 1?
>>Все просто, нам необходимо найти индекс элемента, а не сам элемент. А если мы попытаемся найти его через len() - мы найдем как раз таки сам элемент, а не его индекс (т.к индексы начинаются с нуля)



[[IT]] [[Python]] [[Родительские классы/IT/Python/Leetcode|Leetcode]]
