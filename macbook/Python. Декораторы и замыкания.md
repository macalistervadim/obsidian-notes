
Декораторы позволяют нам изменить поведение нашей входной функции, при этом не меняя ее структуры

```python
def decor(func):
	return func

@decor
def request():
	print("Hello world")

request() # Hello world
```

Как видим - мы уже применили на практике такой прием как `декорирование` - но по факту ведь ничего не изменилось? Да, верно, ведь мы просто передали в наш декоратор входную функцию и в самом декораторе ее же и вернули - тоесть не сделали ничего с входными данными. `@decorator` это своего рода синтаксический сахар, позволяющий нам писать `питонячий код`. По факту все что заменяет этот синтаксический сахар, это использование конструкции `decor(func)` - согласитесь, вариант с `@` намного красивее выглядит и удобнее в использовании

Теперь более сложный пример

```python

def decor(func):
	def wrapper():
		func()
		result = "Hello decorator's"
		return result
	return wrapper

@decor
def request():
	print("Hello world")

request() 
# Hello world
# Hello decorator's
```

В данном примере используется `замыкание` 

>[!warning] Замыкание
>Замыкание - это некий захват области переменных из внешней функции (в примере выше - из функции `decor()`) в свою, "замкнутую" область видимости. Это позволяет нам использовать такие переменные в замкнутой функции даже после завршения работы внешней

Тоесть как мы видим из примера выше - наша функция все также выполняется, но при этом она задействует приемы любимого ООП, изменяя поведение нашей функции без изменения ее реализации

[[Python]] [[IT]]