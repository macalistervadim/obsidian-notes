> Объектно-ориентированное программирование сложная и коварная штука

>[!warning] Чуть чуть о PEP8
>В питоне для указания **формальной приватности**, именно формальной, используется нижнее подчеркивание в начале атрибута  / свойства / метода класса. Это сигнализирует других разработчиков использовать данную сущность лишь в пределах самого класса

>[!note] `__qualname__`
>Данный атрибут стоит использовать для получения более подробного описания типа сущности
>`type(42).__qualname__`

# Коварность наследования классов

> не стоит злоупотреблять наследованием классов,  т.к это может сыграть злую шутку в дальнейшем


>[!note] функция `super()`
>данная функция позволяет нам не дублировать код метода в дочернем классе а скопировать реализацию этого метода у родительского класса. Точнее не скопировать - а вызвать тот или иной метод у родительского класса в нашем дочернем. Так, мы оберегаем себя от ситуации, когда меняем что-либо в родительском классе, а потом нам необходимо менять все тоже самое в дочерних
>
>==**Интересный факт**==
>если случится ситуация, что мы используем `super()`, а у наших (допустим двух) родительских классах совпадают методы, то будет взят ПЕРВЫЙ родительский класс за основу для копирования

# Композиция VS Наследование

> Нада будет еще чуток допонять шо эт за штуковина...

Композиция позволяет нам **копировать к дочерний класс родительский**, но при этом присваивая этот родительский класс одному из атрибутов дочернего (ТЯЖЕЛО!!!)
В общем грубо говоря мы не наследуемся (не пренадлежим) родительскому классу, а именно копируем его реализацию в атрибут нашего класса, дабы в дальнейшем использовать его в методах

# Проверяем принадлежность типа

>[!note] `isinstance()`
>Если возникла необходимость сравнить два объекта на принадлежность (напомню, что в питоне все является объектами) - то стоит использовать функцию `isinstance()`, которая позволяет нам сделать это
>`isinstance(42, int) # True` 

# Второй `__init__`

> На самом деле этот кроказябр используется не только в таких случаях

@==classmethod== позволяет нам определить метод класса, который может (используется) без определения экземпляра класса. Тоесть мы можем вызвать его без необходимости создавать новый экземпляр на основе класса. `per = ClassOther() # создаем экземпляр` 
`per = ClassOther.otherclassmethod() # напрямую обращаемся к методу класса`

# Сеттеры геттеры делетеры

> setter, getter, deleter

>[!warning] Пускай будет в голове
>Данные свойства служат для низкоуровнего контроля над поведением наших методов класса. Мы можем запретить изменять метод, запретить удалять и т.д при помощи вот этих штук

#### Дополнение поведения базовых классов

Нам также никто не запрещает дополнять поведение базовых структур и в целом классов Python. Условно есть необходимость нам сделать так, чтобы dict еще и выполнял некую функцию `blabla()` - мы можем создать класс и наследоваться от dict, чтобы расширить его и в дальнейшем использовать уже переопределенный класс для собственных нужд


[[IT]] [[Python]]

