
Функции в го максимально похожи на аннотированные питонячие функции - и это супер!

```go
func findAllDecimal(a string) string {
	// тело функции
}
```

В данном примере мы создаем функцию findAllDecimal в сигнатуре которой мы принимаем значение a в виде стринга и возвращаем стринг 
Кстати, вот пример такой же функции из питона:

```python
def findAllDecimal(a: string) -> string:
	# Тело функции
```
Максимально похожи, правда?)

Мы также можем задавать функции с несколькими параметрами одинакового типа и при этом не писать после каждой из них тип в таком случае

```go
func findAllDecimal(a, b, c string) string {
	// тело функции
}
```

В данном примере у нас функция требует в аргументах передать 3 объекта типа string

### Функции без возвращаемого значения

Также мы можем задавать функции которые ничего не возвращают (None из питона) - попросту не задавая возвращаемое значение в конце сигнатуры функции

### Функции с множественным возвратом

Как и в питоне, абсолютно с идентичной логикой мы можем создать функцию, которая будет возвращать сразу несколько значений

```go
func someFunc(a, b, c string) (string, string, string) {
	return a, b, c
}

name, age, length := someFunc("a", "b", "c")

```

Абсолютно похожая конструкция на питон - тем самым и логика работы абсолютно похожая

### Возврат ошибок

Т.к у нас типизированный язык - то при множественном возвращаемом значении мы даже при ошибках должны вернуть все указанные значения (если их 3 - вернуть 3, 4 - 4)

```go
func devide(a, b int) (int, error) {
    if b == 0 {
        // Возвращаем 0 и ошибку, если возникает деление на 0:
        return 0, fmt.Errorf("wrong divider with value %v", b)
    }
    
    result := a / b
    
    return result, nil // Возвращаем результат и nil, если ошибки нет
}
```

Сигнатура нашей функции указывает, что возвращаемых значений типа int, error будет 2 - соответственно мы обязаны вернуть эти 2 значения, иначе возникнет ошибка. Мы так и делаем, просто при ошибочном варианте мы попросту вместо result возвращаем 0, а ошибку отображаем - тем самым указывая на эту самую ошибку.

>[!warning] Важное замечание
>В GO по общепринятым правилам необходимо возвращать ошибки последними, тобишь все ероры в return должны стоять последним значением

### Рекурсия

Очередной питон, дада)

```go
func factorial(n int) int {
    // крайний случай
    if n == 0 {
        return 1
    }
    
    // вызов функции с текущим значением, умноженным на результат (n - 1)
    return n * factorial(n - 1)
}

func main() {
    result := factorial(5)
    fmt.Println(result)
}
```

Тут все наглядно видно, работает также при помощи СТЕКА - на этом все)

[[Go]] [[IT]]