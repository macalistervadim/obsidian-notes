> SOLID - всеми известные и повсеместно используемые принципы разработки чистого кода, собранные Робертом Мартином и аудиторией программистов того времени (90-е годы)

Принципы SOLID определяют, как объединять функции и структуры данных в классы и как эти классы должны сочетаться друг с другом. ==Использование слова "класс" не означает, что эти принципы применимы только к ООП.==

## Принцип единой ответственности (SRP)

Single Responsibility Principle - это принцип единой ответственности. Вкратце суть его заключается в том, что наш класс должен отвечать только за одну зону ответственности. Не "делать что то одно и только одно", а именно отвечать за "одну и только одну зону ответственности, или же объект (актер, группа и пр)". 

##### “Класс должен отвечать за что-то одно и только одно” (Uncle Bob)

Здесь смысл глубже: **класс объединяет все функции и методы, которые относятся к одной ответственности**, а не просто одну операцию.

Пример с Employee:

```python
class Employee:
    def calculate_payroll(self): ...
    def save_to_database(self): ...
    def assign_vacation_days(self): ...

```

- **Payroll** → бухгалтерия
    
- **Vacation** → HR
    
- **Database** → хранение данных


Тут ответственность **разная**, хотя все методы связаны с Employee. Поэтому SRP предлагает **разделить на разные классы по ответственности**, а не просто по количеству методов:

```python
class PayrollProcessor:
    def calculate_payroll(self): ...

class HRManager:
    def assign_vacation_days(self): ...

class EmployeeRepository:
    def save_to_database(self): ...
```

То есть принцип теперь не про “одна функция = один класс”, а **“класс отвечает за один аспект системы”**.

## Принцип открытости/закрытости (OCP)

**Open/Closed Principle** — _программные сущности должны быть открыты для расширения, но закрыты для модификации_.

Это значит, что:

- **“Открыты”** — мы можем добавлять новое поведение, новые варианты работы;
    
- **“Закрыты”** — не нужно менять уже существующий код, чтобы это поведение добавить.
    

### 💡 Смысл по Марину:

Он не говорит, что **нельзя менять код вообще**, а что **архитектура должна быть спроектирована так**, чтобы новые фичи **добавлялись через расширение**, а не через правку старых модулей.

Например, если нам нужно добавить новый тип отчёта, мы не лезем менять `ReportGenerator`, а просто создаём новый класс, реализующий общий интерфейс.

```python
class Report:
    def generate(self):
        pass

class PDFReport(Report):
    def generate(self):
        # PDF generation logic
        pass

class ExcelReport(Report):
    def generate(self):
        # Excel generation logic
        pass

```

Теперь, если нужно добавить, скажем, `HTMLReport`, мы **не трогаем старые классы**, а просто **расширяем систему новым**.

> 📌 OCP тесно связан с **абстракциями**: мы изначально закладываем интерфейсы и базовые контракты, чтобы конкретные реализации можно было менять и добавлять без модификации старого кода.

### ⚙️ Пример из реальной жизни:

- Если класс нарушает OCP, каждая новая фича требует лезть внутрь и редактировать.
    
- Если соблюдает — ты просто добавляешь новый модуль, и всё “подключается” через интерфейсы или DI.

## Принцип подстановки Лисков (LSP)

**Liskov Substitution Principle** — _объекты в программе должны быть заменяемы их подтипами без нарушения корректности работы программы._

📘 Сформулирован Барбарой Лисков в 1987 году.

### 💡 Смысл по Мартину:

Этот принцип — **проверка корректности наследования**. Если ты сделал подкласс, он должен **вести себя как родитель**, а не ломать логику программы, где ожидается базовый тип.

> “Если `S` — подтип `T`, то объекты типа `T` в программе можно заменить объектами типа `S` без изменения желаемых свойств этой программы.”

### 🚫 Нарушение LSP:

```python
class Bird:
    def fly(self):
        print("I can fly")

class Ostrich(Bird):
    def fly(self):
        raise Exception("I can't fly!")

```

В этом случае `Ostrich` **не может подставляться вместо `Bird`**, потому что ломает ожидаемое поведение. Нарушение LSP → архитектура становится хрупкой.

### ✅ Соблюдение LSP:

Использовать более точные абстракции:

```python
class Bird:
    pass

class FlyingBird(Bird):
    def fly(self):
        print("I can fly")

class Ostrich(Bird):
    pass

```

Теперь `Ostrich` не нарушает поведение — он просто не умеет летать, но и программа этого не ждёт.

---

### 💬 По сути:

LSP гарантирует, что **наследование используется корректно** — подклассы должны **расширять поведение**, а не **изменять контракт** базового класса.

Если LSP нарушается — это сигнал, что нужно:

- либо пересмотреть иерархию классов,
    
- либо использовать **композицию вместо наследования**.

LSP говорит не про то, **что класс имеет те же методы**, а про то, что **подкласс или реализация сохраняет смысл, поведение и контракт**, который ожидает клиентский код.

---

### 🔍 пример с REST — просто идеален:

Допустим, у нас есть базовый интерфейс:

```python
class RestClient:
    def get(self, url): ...
    def post(self, url, data) -> Reponse[POST]: ...

```
Клиентский код ожидает, что:

- `post()` действительно отправит **POST**-запрос,
    
- и вернёт **результат POST**,
    
- с **определённым поведением**: заголовки, тело, статус.
    

Теперь ты делаешь подкласс:

```python
class MyRestClient(RestClient):
    def post(self, url, data) -> Headers:
        # вместо POST делаем HEAD 🤡
        return super().head(url)

```

Код **работает**, сигнатура метода совпадает — но поведение **сломано**.  
LSP нарушен:  
клиент, который вызывал `post()`, ожидает, что **будет создан ресурс**,  
а не что просто вернутся заголовки.

### ⚙️ В терминах LSP:

> Подтип должен быть **взаимозаменяем** с базовым типом  
> без нарушения **инвариантов**, **пред-** и **постусловий**.

- **Инварианты** — общие правила (например, `post` создаёт ресурс).
    
- **Предусловия** — что можно передавать (например, `data` не `None`).
    
- **Постусловия** — что вернётся (например, `response.status == 201`).
    

Если ты изменяешь поведение (например, `post` возвращает `HEAD`),  
ты нарушаешь контракт → **нарушаешь LSP**.

---

### 🚨 Почему это важно:

Код, который зависит от абстракции, перестаёт быть предсказуемым.  
Это делает систему **хрупкой** — ты можешь подставить “совместимый класс”,  
но он внезапно поведёт себя по-другому.

🧠 **Итоговая мысль:**

- LSP ≠ просто “те же методы”.
    
- LSP = “то же поведение, тот же контракт”.
    
- Если твоя реализация **ломает ожидания** — значит, **LSP нарушен**.
    
- В таких случаях часто лучше использовать **композицию** или **новую абстракцию**, а не наследование.