> SOLID - всеми известные и повсеместно используемые принципы разработки чистого кода, собранные Робертом Мартином и аудиторией программистов того времени (90-е годы)

Принципы SOLID определяют, как объединять функции и структуры данных в классы и как эти классы должны сочетаться друг с другом. ==Использование слова "класс" не означает, что эти принципы применимы только к ООП.==

## Принцип единой ответственности (SRP)

Single Responsibility Principle - это принцип единой ответственности. Вкратце суть его заключается в том, что наш класс должен отвечать только за одну зону ответственности. Не "делать что то одно и только одно", а именно отвечать за "одну и только одну зону ответственности, или же объект (актер, группа и пр)". 

##### “Класс должен отвечать за что-то одно и только одно” (Uncle Bob)

Здесь смысл глубже: **класс объединяет все функции и методы, которые относятся к одной ответственности**, а не просто одну операцию.

Пример с Employee:

```python
class Employee:
    def calculate_payroll(self): ...
    def save_to_database(self): ...
    def assign_vacation_days(self): ...

```

- **Payroll** → бухгалтерия
    
- **Vacation** → HR
    
- **Database** → хранение данных


Тут ответственность **разная**, хотя все методы связаны с Employee. Поэтому SRP предлагает **разделить на разные классы по ответственности**, а не просто по количеству методов:

```python
class PayrollProcessor:
    def calculate_payroll(self): ...

class HRManager:
    def assign_vacation_days(self): ...

class EmployeeRepository:
    def save_to_database(self): ...
```

То есть принцип теперь не про “одна функция = один класс”, а **“класс отвечает за один аспект системы”**.

## Принцип открытости/закрытости (OCP)

**Open/Closed Principle** — _программные сущности должны быть открыты для расширения, но закрыты для модификации_.

Это значит, что:

- **“Открыты”** — мы можем добавлять новое поведение, новые варианты работы;
    
- **“Закрыты”** — не нужно менять уже существующий код, чтобы это поведение добавить.
    

### 💡 Смысл по Марину:

Он не говорит, что **нельзя менять код вообще**, а что **архитектура должна быть спроектирована так**, чтобы новые фичи **добавлялись через расширение**, а не через правку старых модулей.

Например, если нам нужно добавить новый тип отчёта, мы не лезем менять `ReportGenerator`, а просто создаём новый класс, реализующий общий интерфейс.

```python
class Report:
    def generate(self):
        pass

class PDFReport(Report):
    def generate(self):
        # PDF generation logic
        pass

class ExcelReport(Report):
    def generate(self):
        # Excel generation logic
        pass

```

Теперь, если нужно добавить, скажем, `HTMLReport`, мы **не трогаем старые классы**, а просто **расширяем систему новым**.

> 📌 OCP тесно связан с **абстракциями**: мы изначально закладываем интерфейсы и базовые контракты, чтобы конкретные реализации можно было менять и добавлять без модификации старого кода.

### ⚙️ Пример из реальной жизни:

- Если класс нарушает OCP, каждая новая фича требует лезть внутрь и редактировать.
    
- Если соблюдает — ты просто добавляешь новый модуль, и всё “подключается” через интерфейсы или DI.

## Принцип подстановки Лисков (LSP)

**Liskov Substitution Principle** — _объекты в программе должны быть заменяемы их подтипами без нарушения корректности работы программы._

📘 Сформулирован Барбарой Лисков в 1987 году.

### 💡 Смысл по Мартину:

Этот принцип — **проверка корректности наследования**. Если ты сделал подкласс, он должен **вести себя как родитель**, а не ломать логику программы, где ожидается базовый тип.

> “Если `S` — подтип `T`, то объекты типа `T` в программе можно заменить объектами типа `S` без изменения желаемых свойств этой программы.”

### 🚫 Нарушение LSP:

```python
class Bird:
    def fly(self):
        print("I can fly")

class Ostrich(Bird):
    def fly(self):
        raise Exception("I can't fly!")

```

В этом случае `Ostrich` **не может подставляться вместо `Bird`**, потому что ломает ожидаемое поведение. Нарушение LSP → архитектура становится хрупкой.

### ✅ Соблюдение LSP:

Использовать более точные абстракции:

```python
class Bird:
    pass

class FlyingBird(Bird):
    def fly(self):
        print("I can fly")

class Ostrich(Bird):
    pass

```

Теперь `Ostrich` не нарушает поведение — он просто не умеет летать, но и программа этого не ждёт.

---

### 💬 По сути:

LSP гарантирует, что **наследование используется корректно** — подклассы должны **расширять поведение**, а не **изменять контракт** базового класса.

Если LSP нарушается — это сигнал, что нужно:

- либо пересмотреть иерархию классов,
    
- либо использовать **композицию вместо наследования**.

LSP говорит не про то, **что класс имеет те же методы**, а про то, что **подкласс или реализация сохраняет смысл, поведение и контракт**, который ожидает клиентский код.

---

### 🔍 пример с REST — просто идеален:

Допустим, у нас есть базовый интерфейс:

```python
class RestClient:
    def get(self, url): ...
    def post(self, url, data) -> Reponse[POST]: ...

```
Клиентский код ожидает, что:

- `post()` действительно отправит **POST**-запрос,
    
- и вернёт **результат POST**,
    
- с **определённым поведением**: заголовки, тело, статус.
    

Теперь ты делаешь подкласс:

```python
class MyRestClient(RestClient):
    def post(self, url, data) -> Headers:
        # вместо POST делаем HEAD 🤡
        return super().head(url)

```

Код **работает**, сигнатура метода совпадает — но поведение **сломано**.  
LSP нарушен:  
клиент, который вызывал `post()`, ожидает, что **будет создан ресурс**,  
а не что просто вернутся заголовки.

### ⚙️ В терминах LSP:

> Подтип должен быть **взаимозаменяем** с базовым типом  
> без нарушения **инвариантов**, **пред-** и **постусловий**.

- **Инварианты** — общие правила (например, `post` создаёт ресурс).
    
- **Предусловия** — что можно передавать (например, `data` не `None`).
    
- **Постусловия** — что вернётся (например, `response.status == 201`).
    

Если ты изменяешь поведение (например, `post` возвращает `HEAD`),  
ты нарушаешь контракт → **нарушаешь LSP**.

---

### 🚨 Почему это важно:

Код, который зависит от абстракции, перестаёт быть предсказуемым.  
Это делает систему **хрупкой** — ты можешь подставить “совместимый класс”,  
но он внезапно поведёт себя по-другому.

🧠 **Итоговая мысль:**

- LSP ≠ просто “те же методы”.
    
- LSP = “то же поведение, тот же контракт”.
    
- Если твоя реализация **ломает ожидания** — значит, **LSP нарушен**.
    
- В таких случаях часто лучше использовать **композицию** или **новую абстракцию**, а не наследование.

# Принцип Разделения Интерфейсов

ISP требует: **не заставляйте объекты реализовывать лишние методы**, которые им не нужны.

```python
class User:
    def op1(self): ...
    def op2(self): ...
    def op3(self): ...

```

Если разные подклассы используют разные операции (`User1` только `op1`, `User2` только `op2`), лучше разделить интерфейс:

```python
class UserOp1:
    def op1(self): ...

class UserOp2:
    def op2(self): ...

```

✅ Так классы не нагружены лишними методами, интерфейсы чистые.

# 🔹 Dependency Inversion Principle (DIP)

### 💡 Суть:

> Модули высокого уровня не должны зависеть от модулей низкого уровня.  
> И те, и другие должны зависеть от **абстракций**.  
> Абстракции не должны зависеть от деталей, детали должны зависеть от абстракций.

Проще: **сервис работает через интерфейсы**, а не напрямую через конкретные реализации.

---

### 🚫 Нарушение DIP:

```python 
class UserService:
    def __init__(self):
        self.repo = SQLAlchemyUsersRepository()  # конкретная реализация

    async def register_user(self, user):
        await self.repo.add(user)

```

**Проблема:**

- `UserService` жёстко привязан к `SQLAlchemyUsersRepository`.
    
- Если завтра мы захотим использовать другой репозиторий (например, Mongo), придётся менять `UserService`.
    
- Код низкого и высокого уровней связан напрямую — DIP нарушен.
    

---

### ✅ Соблюдение DIP:

```python
class IUserRepository(abc.ABC):
    @abc.abstractmethod
    async def add(self, user): ...

class UserService:
    def __init__(self, repo: IUserRepository):
        self.repo = repo

    async def register_user(self, user):
        await self.repo.add(user)

```

Теперь `UserService` работает **через интерфейс**, а конкретная реализация репозитория может меняться без правок сервиса.

---

### 🔍 Фабрика + DIP

Фабрика нужна, чтобы **инстанцировать конкретную реализацию интерфейса** и передать её в сервис:

```python
class UsersRepositoryFactory:
    def create(self) -> IUserRepository:
        return SQLAlchemyUsersRepository()  # конкретная реализация

```

И внедрение в сервис через DI:

```python
repo = UsersRepositoryFactory().create()
service = UserService(repo=repo)

```

Если завтра решим сменить репозиторий:

```python
class MongoUsersRepository(IUserRepository): ...

```

Нужно будет поменять только **фабрику**, сервис остаётся неизменным.

---

### ⚙️ DI в FastAPI

В FastAPI это выглядит примерно так:

```python
async def get_user_repo() -> IUserRepository:
    return SQLAlchemyUsersRepository(session=await get_session())

async def get_user_service(repo: IUserRepository = Depends(get_user_repo)):
    return UserService(repo=repo)

```

- `UserService` **не знает о SQLAlchemy** — только об интерфейсе.
    
- Фактический репозиторий передаётся через DI.
    

---

### 💬 Итог:

- DIP = **высокий уровень зависит от абстракций, а не от деталей**.
    
- Сервисы работают через интерфейсы.
    
- Фабрики и DI помогают подменять реализации без изменений кода.
    
- Благодаря этому код становится **гибким и тестируемым**.

[[Родительские классы/IT/Архитектура/Архитектура|Архитектура]] [[IT]]