> В питоне мы все объекты называем  **динамически типизированными**, почему так? Все просто. Мы можем в следствие жизни нашей программы мутировать (mutable) наше значение из одного поддерживаемого типа данных в другой

Аннотации типов ведут за собой лишь ознакомительный характер и никоем образом не меняют конечное поведение нашего приложения

**Пример 1**
>[!example]
```python
def nameUser(name: str, age: int) -> str:  # В сигнатуре функции определяем типизацию наших параметров и также возвращаемое значение
	return f"Привет {name}, тебе {age} лет."
```
==Такой случай в целом применим, но в небольших программах. В реальных же проектах чаще будет встречаться следующий пример==


**Пример 2**
>[!example]
```python
def nameUser(age: int | float, name: str | None = None) -> str:
	if name:
		return f"Привет {name}, у тебя крутой возраст: {age}!"
	else:
		return f"Аноним! у тебя крутой возраст, {age}."
```
 >[!danger]
 >Параметры с аргументами по умолчанию должны следовать после параметров без аргументов по умолчанию

**Также прошу заметить здесь некую синтаксическую ошибку в аннотации типов - при аннотации типа `int / float` не стоит указывать их вместе. Если объект поддерживает `int` и `float` - можно просто записать один из них**

В данном примере мы задействовали библиотеку **typing**. Запись типа `name: str | None` эквивалентна записи `name: typing.Union[str, None]`

 В модуле typing есть следующие аннотации типов:
 - ==Any== -  Значение любого типа. Пример: `name: Any = "Aleks"`
 - ==Optional== - Используется для записи необязательных параметров за место записи `name: Union[str, None] = None`. Пример: `name: Optional[str] = None`
 - ==Union== - Используется для указания нескольких типов данных для объекта. Пример: `name: Union[str, int, float, bool]`
 - ==List== - Используется для указания типов данных списка. Пример: `numbers: List[Union[str, float, int]] = []`.  ==Точно таким же макаром для dict, tuple, set==
 - ==Final== - Для указания констант. Пример: `NAME: Final = "Vadim"`
 - ==Literal== - Используется для указания конкретного значения. Пример: `name: Literal["Alice", "Bob"]`
 - ==NoReturn== - В основном используется для разных обработчиков ошибок, которые не возвращают ничего в место вызова функции. **Прошу заметит**ь, это не эквивалентно None, все таки они используются в разных ситуациях
 - ==TypeAlias== - Используется для создания псевдонима, тобишь когда у нас есть некий "необычный" тип данных и нам необходимо явно указать, что он означает. Пример: `Celsius: TypeAliac = int` - теперь мы можем использовать нашу переменную `Celsius` в своем коде с пониманием, что вообще подразумевает она
 - ==Enum== - про него чуть подробнее ниже, оч уж зашел)
 >[!note] Коротко о Enum
 >Если у нас есть необходимость допустим в нашей функции использовать какие-либо конкретные значения, то мы можем это задать, как раз используя **Enum**
 >>[!example] Небольшой примерчик
 ```python
from datetime import datetime
from enum import Enum

class WeatherType(Enum):
    THUNDERSTORM = "Гроза"
    DRIZZLE = "Изморось"
    RAIN = "Дождь"
    SNOW = "Снег"
    CLEAR = "Ясно"
    FOG = "Туман"
    CLOUDS = "Облачно"

@dataclass(slots=True, frozen=True)
class Weather:
    temperature: Celsius
    weather_type: WeatherType
    sunrise: datetime
    sunset: datetime
	city: str
```

>[!warning] Важно
>По возможности вместо указания в типах list, dict и т. п. указывай классы Iterable, Sequence, Mapping.
>
Во-первых, это позволит менять конкретные реализации, удовлетворяющие условию итерабельности, доступа по индексу или доступа по ключу соответственно, решение получится более гибким.
>
Во-вторых, анализатор кода mypy будет лучше работать с такими типами данных, что позволит избежать некоторых осложнений.
>
Если от контейнера требуется итерабельность (чтобы по данным в контейнере можно было итерироваться, то есть проходить в цикле), то стоит указать Iterable, который гарантирует именно итерабельность, вместо того, чтобы указывать одни из возможных реализаций итерабельных контейнеров вроде list или tuple, несущих помимо собственно итерабельности и другие свойства.
>
Если от контейнера требуется доступ по индексу, то стоит указать Sequence, а не одну из возможных реализаций вроде list.
>
>Наконец, если требуется доступ по ключу, то следует указать Mapping.


[[IT]] [[Python]] 